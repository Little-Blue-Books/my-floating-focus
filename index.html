<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Floating Focus | Seamless Canvas</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Floating Focus">
    <meta name="theme-color" content="#ffffff">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Kiwi+Maru:wght@400;500&family=Inter:wght@400;600;700&display=swap"
        rel="stylesheet">

    <!-- Frameworks -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        :root {
            --canvas-bg: #ffffff;
            --text-primary: #2d3436;
            --note-size: 140px;
            --note-size-mobile: 115px;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden !important;
            position: fixed;
            background-color: var(--canvas-bg);
            font-family: 'Kiwi Maru', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #root,
        #canvas {
            width: 100vw;
            height: 100vh;
            position: relative;
            touch-action: none;
            overflow: hidden;
        }

        .header {
            position: fixed;
            top: env(safe-area-inset-top, 1.25rem);
            left: 1.5rem;
            z-index: 1000;
            pointer-events: none;
        }

        .title {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-primary);
            opacity: 0.3;
            letter-spacing: 1.5px;
            font-family: 'Inter', sans-serif;
            text-transform: uppercase;
        }

        /* 入力エリア：常に最前面 */
        .input-container {
            position: fixed;
            top: env(safe-area-inset-top, 1.2rem);
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            width: 90%;
            max-width: 500px;
            box-sizing: border-box;
            pointer-events: none;
        }

        .input-wrapper {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(15px);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.5rem;
            border-radius: 18px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.1);
            pointer-events: auto;
        }

        input {
            flex: 1;
            min-width: 0;
            border: none;
            padding: 0.6rem 0.8rem;
            font-size: 16px;
            outline: none;
            background: transparent;
            color: var(--text-primary);
            font-family: 'Kiwi Maru', sans-serif;
        }

        .add-btn {
            background: #2d3436;
            color: white;
            border: none;
            padding: 0.7rem 1.4rem;
            border-radius: 14px;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 0.95rem;
            touch-action: manipulation;
        }

        /* 付箋コンテナ：ライブラリを使わず、絶対座標で制御 */
        .note-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: var(--note-size);
            height: var(--note-size);
            will-change: transform;
            /* 拡大時のみ z-index を上げる */
            z-index: 10;
        }

        /* 付箋本体 */
        .sticky-note {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: #fff9c4;
            /* デフォルトカラー */
            border-radius: 2px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06);
            background-image: linear-gradient(180deg, rgba(255, 255, 255, 0.1) 0%, rgba(0, 0, 0, 0.04) 100%);
            box-sizing: border-box;
            touch-action: none;

            /* アニメーション：CSS transitionに一本化 */
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28), box-shadow 0.3s ease;
            transform: scale(1);
        }

        /* アクティブ（タップ中）のスタイル：Safariでも確実に効かせる */
        .note-wrapper.is-active {
            z-index: 1000;
        }

        .note-wrapper.is-active .sticky-note {
            transform: scale(1.4);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        .note-wrapper.is-dragging .sticky-note {
            transition: none;
            /* ドラッグ中は追従を優先するためtransitionを切る */
        }

        @media (max-width: 600px) {
            .note-wrapper {
                width: var(--note-size-mobile);
                height: var(--note-size-mobile);
            }

            .note-text {
                font-size: 0.85rem;
            }

            .folded-corner {
                border-width: 12px;
            }
        }

        .folded-corner {
            position: absolute;
            top: 0;
            right: 0;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 16px 16px 0;
            border-color: transparent white transparent transparent;
            z-index: 2;
        }

        /* 削除ボタンを付箋の外側に配置しやすくする */
        .delete-btn-area {
            position: absolute;
            bottom: -15px;
            right: -15px;
            z-index: 1100;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(0, 0, 0, 0.05);
            color: rgba(0, 0, 0, 0.4);
            font-size: 1.5rem;
            cursor: pointer;
            touch-action: manipulation;
        }

        .note-text {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--text-primary);
            line-height: 1.4;
            word-wrap: break-word;
            pointer-events: none;
        }

        .view-toggle {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 1.5rem);
            right: 1.5rem;
            z-index: 9000;
        }

        .toggle-pill {
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            padding: 0.75rem 1.75rem;
            border-radius: 30px;
            font-size: 0.9rem;
            color: var(--text-primary);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }

        .list-container {
            padding: 10rem 2rem 2rem;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 2.5rem;
            height: 100vh;
            overflow-y: auto;
            box-sizing: border-box;
            touch-action: pan-y;
        }

        /* リストモード用の付箋調整 */
        .list-container .note-wrapper {
            position: relative;
            top: auto !important;
            left: auto !important;
            transform: none !important;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, useCallback } = React;

        // --- Utils: LocalStorage ---
        const STORAGE_KEY = 'FloatingFocus_v20_StableStore';
        const saveTasks = (tasks) => {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
            } catch (e) { }
        };
        const loadTasks = () => {
            try {
                const s = localStorage.getItem(STORAGE_KEY);
                return s ? JSON.parse(s) : null;
            } catch (e) { return null; }
        };

        // --- Audio Logic ---
        let audioCtx = null;
        const playPop = () => {
            try {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === "suspended") audioCtx.resume();
                const o = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                o.type = "sine";
                o.frequency.setValueAtTime(800, audioCtx.currentTime);
                o.frequency.exponentialRampToValueAtTime(120, audioCtx.currentTime + 0.1);
                g.gain.setValueAtTime(0.3, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                o.connect(g); g.connect(audioCtx.destination);
                o.start(); o.stop(audioCtx.currentTime + 0.12);
            } catch (e) { }
        };

        const SoapBubbleNote = ({ task, onDelete, windowSize, isListMode }) => {
            // 位置・状態の管理
            const [pos, setPos] = useState({ x: 0, y: 0 });
            const [rotation, setRotation] = useState(0);
            const [status, setStatus] = useState('floating'); // floating, dragging, active

            const posRef = useRef({ x: 0, y: 0 }); // ドラッグ・アニメーション用
            const dragRef = useRef({ startX: 0, startY: 0, initialX: 0, initialY: 0 });
            const colors = ['#fff9c4', '#fce4ec', '#e3f2fd', '#f1f8e9'];
            const bgColor = useMemo(() => colors[Math.floor(Math.random() * colors.length)], []);

            const isMobile = windowSize.width < 600;
            const size = isMobile ? 115 : 140;

            // 初期位置
            useEffect(() => {
                const x = Math.random() * (windowSize.width - size);
                const y = Math.random() * (windowSize.height - size);
                posRef.current = { x, y };
                setPos({ x, y });
            }, []);

            // 浮遊アニメーション
            useEffect(() => {
                if (isListMode || status !== 'floating') return;

                let raf;
                let target = { x: Math.random() * (windowSize.width - size), y: Math.random() * (windowSize.height - size) };
                let startTime = performance.now();
                const duration = 15000 + Math.random() * 10000;
                const startPos = { ...posRef.current };

                const step = (time) => {
                    if (status !== 'floating') return;
                    const elapsed = time - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // イージング
                    const ease = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                    posRef.current = {
                        x: startPos.x + (target.x - startPos.x) * ease,
                        y: startPos.y + (target.y - startPos.y) * ease
                    };
                    setPos({ ...posRef.current });
                    setRotation(Math.sin(elapsed / 2000) * 5);

                    if (progress < 1) {
                        raf = requestAnimationFrame(step);
                    } else {
                        // 次の目的地へ
                        startTime = performance.now();
                        target = { x: Math.random() * (windowSize.width - size), y: Math.random() * (windowSize.height - size) };
                        startPos.x = posRef.current.x;
                        startPos.y = posRef.current.y;
                        raf = requestAnimationFrame(step);
                    }
                };

                raf = requestAnimationFrame(step);
                return () => cancelAnimationFrame(raf);
            }, [status, isListMode, windowSize, size]);

            // ドラッグ実装
            const handlePointerDown = (e) => {
                if (e.target.closest('.delete-btn-area')) return;
                setStatus('active');
                dragRef.current = {
                    startX: e.clientX,
                    startY: e.clientY,
                    initialX: posRef.current.x,
                    initialY: posRef.current.y
                };
                window.addEventListener('pointermove', handlePointerMove);
                window.addEventListener('pointerup', handlePointerUp);
            };

            const handlePointerMove = (e) => {
                setStatus('dragging');
                const dx = e.clientX - dragRef.current.startX;
                const dy = e.clientY - dragRef.current.startY;

                posRef.current = {
                    x: Math.min(Math.max(0, dragRef.current.initialX + dx), windowSize.width - size),
                    y: Math.min(Math.max(0, dragRef.current.initialY + dy), windowSize.height - size)
                };
                setPos({ ...posRef.current });
            };

            const handlePointerUp = () => {
                setStatus('floating');
                window.removeEventListener('pointermove', handlePointerMove);
                window.removeEventListener('pointerup', handlePointerUp);
            };

            const wrapperStyle = isListMode ? {} : {
                transform: `translate3d(${pos.x}px, ${pos.y}px, 0) rotate(${rotation}deg)`
            };

            return (
                <div
                    className={`note-wrapper ${status !== 'floating' ? 'is-active' : ''} ${status === 'dragging' ? 'is-dragging' : ''}`}
                    style={wrapperStyle}
                    onPointerDown={isListMode ? null : handlePointerDown}
                >
                    <div className="sticky-note" style={{ backgroundColor: bgColor }}>
                        <div className="folded-corner"></div>
                        <div className="note-text">{task.text}</div>
                        <div
                            className="delete-btn-area"
                            onPointerDown={e => { e.stopPropagation(); playPop(); onDelete(task.id); }}
                        >×</div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [tasks, setTasks] = useState(() => {
                const saved = loadTasks();
                return saved !== null ? saved : [
                    { id: 1, text: "深呼吸をしてみる" },
                    { id: 2, text: "少し歩いてみる" }
                ];
            });

            const [inputValue, setInputValue] = useState("");
            const [viewMode, setViewMode] = useState("float");
            const [windowSize, setWindowSize] = useState({ width: window.innerWidth, height: window.innerHeight });

            useEffect(() => {
                saveTasks(tasks);
            }, [tasks]);

            useEffect(() => {
                const update = () => setWindowSize({ width: window.innerWidth, height: window.innerHeight });
                window.addEventListener('resize', update);
                return () => window.removeEventListener('resize', update);
            }, []);

            const addTask = () => {
                if (!inputValue.trim()) return;
                setTasks(prev => [...prev, { id: Date.now(), text: inputValue.trim() }]);
                setInputValue("");
            };

            return (
                <div id="canvas">
                    <header className="header"><div className="title">Floating Focus</div></header>
                    <div className="input-container">
                        <div className="input-wrapper">
                            <input
                                placeholder="いま、頭にあることをそっと浮かべてみる？"
                                value={inputValue}
                                onChange={e => setInputValue(e.target.value)}
                                onKeyPress={e => e.key === 'Enter' && addTask()}
                            />
                            <button className="add-btn" onClick={addTask}>Add</button>
                        </div>
                    </div>

                    <div className="view-toggle">
                        <button className="toggle-pill" onClick={() => setViewMode(viewMode === 'float' ? 'list' : 'float')}>
                            {viewMode === 'float' ? 'リストで整える' : '浮かべて眺める'}
                        </button>
                    </div>

                    <div className={viewMode === 'list' ? 'list-container' : ''}>
                        {tasks.map(task => (
                            <SoapBubbleNote
                                key={task.id}
                                task={task}
                                onDelete={id => setTasks(prev => prev.filter(t => t.id !== id))}
                                windowSize={windowSize}
                                isListMode={viewMode === 'list'}
                            />
                        ))}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

        // モバイルのジェスチャー制限
        document.addEventListener('touchmove', e => {
            if (e.target.closest('.input-wrapper') || e.target.closest('.list-container')) return;
            e.preventDefault();
        }, { passive: false });
    </script>
</body>

</html>
